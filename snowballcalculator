import numpy as np
import pandas as pd

def simulate_gbm(S0, mu, sigma, T, steps_per_year, n_sims, seed=None):
    """
    Simulate Geometric Brownian Motion (GBM) paths.
    """
    rng = np.random.default_rng(seed)
    dt = 1 / steps_per_year
    N = int(T * steps_per_year)
    Z = rng.standard_normal((n_sims, N))
    increments = np.exp((mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z)
    S = np.empty((n_sims, N + 1))
    S[:, 0] = S0
    S[:, 1:] = S0 * np.cumprod(increments, axis=1)
    return S

def calculate_autocall_price(S, S0, knock_in, knock_out, T, steps_per_year, lock_down_period, coupon_rate, risk_free_rate):
    """
    Calculate the price of an autocallable note.
    """
    n_sims, n_steps = S.shape
    dt = 1 / steps_per_year
    lock_down_steps = int(lock_down_period * steps_per_year)
    monthly_steps = int(steps_per_year / 12)

    # Initialize variables
    knocked_in = np.zeros(n_sims, dtype=bool)
    knocked_out = np.zeros(n_sims, dtype=bool)
    payoffs = np.zeros(n_sims)

    for sim in range(n_sims):
        for step in range(1, n_steps):
            price = S[sim, step]

            # Check for knock-in (observed daily)
            if not knocked_in[sim] and price < knock_in * S0:
                knocked_in[sim] = True

            # Check for knock-out (observed monthly after lock-down period)
            if step >= lock_down_steps and step % monthly_steps == 0:
                if price > knock_out * S0:
                    knocked_out[sim] = True
                    # Pay principal + coupon and exit
                    payoffs[sim] = S0 * (1 + coupon_rate * (step / steps_per_year))
                    break

        # If no KO, pay principal + coupon at maturity
        if not knocked_out[sim]:
            if knocked_in[sim]:
                # Knocked in: Pay principal adjusted for final price
                payoffs[sim] = S[sim, -1]
            else:
                # No KI: Pay principal + full coupon
                payoffs[sim] = S0 * (1 + coupon_rate * T)

    # Discount payoffs to present value
    discounted_payoffs = payoffs * np.exp(-risk_free_rate * T)
    return np.mean(discounted_payoffs)

def prompt_user_inputs():
    """
    Prompt the user to specify the initial price, coupon rate, volatility, and futures discount/premium.
    """
    try:
        S0 = float(input("Enter the initial price of the underlying asset (e.g., 100): ").strip())
        coupon_rate = float(input("Enter the annualized coupon rate as a percentage (e.g., 8 for 8%): ").strip()) / 100
        volatility = float(input("Enter the annualized volatility as a percentage (e.g., 20 for 20%): ").strip()) / 100
        futures_discount = float(input("Enter the annual futures discount/premium as a percentage (e.g., -12 for 12% discount, 5 for 5% premium): ").strip()) / 100
        return S0, coupon_rate, volatility, futures_discount
    except ValueError:
        print("Invalid input. Please enter numeric values.")
        sys.exit(1)

if __name__ == "__main__":
    # Prompt user for inputs
    S0, coupon_rate, volatility, futures_discount = prompt_user_inputs()

    # Parameters
    knock_in = 0.8  # Knock-in level (80%)
    knock_out = 1.03  # Knock-out level (103%)
    T = 2  # Maturity in years
    steps_per_year = 244  # Daily steps
    lock_down_period = 3 / 12  # Lock-down period in years (3 months)
    risk_free_rate = 0.02  # Annualized risk-free rate (2%)
    n_sims = 10000  # Number of simulations
    seed = 42  # Random seed for reproducibility

    # Adjust drift for futures discount/premium
    mu = risk_free_rate + futures_discount  # Adjusted drift

    # Simulate GBM paths
    S = simulate_gbm(S0, mu, volatility, T, steps_per_year, n_sims, seed)

    # Calculate autocall price
    autocall_price = calculate_autocall_price(S, S0, knock_in, knock_out, T, steps_per_year, lock_down_period, coupon_rate, risk_free_rate)
    print(f"Autocallable Note Price: {autocall_price:.2f}")